{
  "id": "termux-install-456-def-789-ghi-012-jkl345",
  "name": "Termux - TEST",
  "description": "Automatically downloads and installs/updates the latest Termux app from GitHub releases. Works on all devices in parallel using Python and ADB.",
  "category": "Custom",
  "type": "Python",
  "version": "1.0.0",
  "author": "Cellhasher Team",
  "tags": [
    "python",
    "exported"
  ],
  "effects": {
    "power": {
      "reboot": false,
      "shutdown": false
    },
    "security": {
      "modifiesLockScreen": false
    }
  },
  "preRunNotice": "This Python script was exported from Cellhasher My Scripts.",
  "pythonScript": "import os\nimport time\nimport subprocess\nimport tempfile\nimport urllib.request\nimport json\nimport ssl\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# Windows console encoding fix\nimport sys\nif sys.platform == 'win32':\n    try:\n        import codecs\n        sys.stdout.reconfigure(encoding='utf-8', errors='replace')\n        sys.stderr.reconfigure(encoding='utf-8', errors='replace')\n    except Exception:\n        pass  # Continue if reconfigure fails\n\n# Logging helper function\ndef log_progress(message, log_type=\"info\", device_id=None):\n    \"\"\"\n    Log progress messages in JSON format for Cellhasher to parse\n    \"\"\"\n    import datetime\n    log_entry = {\n        \"timestamp\": datetime.datetime.now().isoformat(),\n        \"type\": log_type,\n        \"category\": \"script\",\n        \"message\": message,\n        \"device_id\": device_id,\n        \"script_name\": \"Termux Install/Update\"\n    }\n    print(f\"[LOG]{json.dumps(log_entry)}[ENDLOG]\")\n\n# Get environment variables from Cellhasher\nADB = os.environ.get(\"adb_path\", \"adb\")\ndevices = os.environ.get(\"devices\", \"\").split()\n\n# GitHub API endpoint for Termux app releases\nGITHUB_API_URL = \"https://api.github.com/repos/termux/termux-app/releases/latest\"\n\ndef setup_ssl_context():\n    \"\"\"\n    Setup SSL context to handle certificate verification issues\n    \"\"\"\n    try:\n        # Try to create unverified context if available (for systems with SSL issues)\n        if hasattr(ssl, '_create_unverified_context'):\n            ssl_context = ssl._create_unverified_context()\n            log_progress(\"SSL: Using unverified context\")\n            return ssl_context\n        else:\n            # Fallback to default context\n            ssl_context = ssl.create_default_context()\n            log_progress(\"SSL: Using default context\")\n            return ssl_context\n    except Exception as e:\n        log_progress(f\"SSL setup warning: {e}\", \"warning\")\n        # Continue without custom SSL context\n        return None\n\ndef get_latest_termux_apk():\n    \"\"\"\n    Fetch the latest Termux arm64-v8a APK download URL from GitHub releases\n    \"\"\"\n    try:\n        log_progress(\"Fetching latest Termux release from GitHub...\")\n\n        # Setup SSL context\n        ssl_context = setup_ssl_context()\n\n        # Add timeout and user agent to avoid potential blocking\n        req = urllib.request.Request(GITHUB_API_URL, headers={'User-Agent': 'Cellhasher-Termux-Updater/1.0'})\n\n        log_progress(\"Connecting to GitHub API...\")\n        # Use SSL context if available\n        if ssl_context:\n            with urllib.request.urlopen(req, timeout=30, context=ssl_context) as response:\n                release_data = json.loads(response.read().decode())\n        else:\n            with urllib.request.urlopen(req, timeout=30) as response:\n                release_data = json.loads(response.read().decode())\n\n        log_progress(f\"Successfully fetched release data for tag: {release_data.get('tag_name', 'unknown')}\")\n\n        # Find the arm64-v8a APK in the assets\n        arm64_assets = []\n        for asset in release_data.get(\"assets\", []):\n            if \"arm64-v8a\" in asset[\"name\"].lower() and asset[\"name\"].endswith(\".apk\"):\n                arm64_assets.append(asset)\n\n        if not arm64_assets:\n            raise Exception(\"Could not find arm64-v8a APK in latest release\")\n\n        # Select the first (and typically only) arm64-v8a APK\n        selected_asset = arm64_assets[0]\n\n        apk_url = selected_asset[\"browser_download_url\"]\n        apk_name = selected_asset[\"name\"]\n        log_progress(f\"Found latest APK: {apk_name}\")\n        log_progress(f\"Download URL: {apk_url}\")\n        return apk_url, apk_name\n\n    except Exception as e:\n        log_progress(f\"Error fetching release info: {e}\", \"error\")\n        raise\n\ndef download_apk(apk_url, apk_name):\n    \"\"\"\n    Download the APK to a temporary location\n    \"\"\"\n    try:\n        # Create temporary file for the APK\n        temp_dir = tempfile.gettempdir()\n        local_apk_path = os.path.join(temp_dir, apk_name)\n        \n        log_progress(f\"Starting download of {apk_name}...\")\n        log_progress(f\"Saving to: {local_apk_path}\")\n        \n        # Add user agent and timeout for better reliability\n        req = urllib.request.Request(apk_url, headers={'User-Agent': 'Cellhasher-Termux-Updater/1.0'})\n\n        # Setup SSL context for download as well\n        ssl_context = setup_ssl_context()\n\n        log_progress(\"Connecting to download server...\")\n        # Use SSL context if available\n        if ssl_context:\n            with urllib.request.urlopen(req, timeout=60, context=ssl_context) as response:\n                with open(local_apk_path, 'wb') as f:\n                    downloaded = 0\n                    while True:\n                        chunk = response.read(8192)\n                        if not chunk:\n                            break\n                        f.write(chunk)\n                        downloaded += len(chunk)\n                        # Log progress every 1MB\n                        if downloaded % (1024 * 1024) == 0:\n                            log_progress(f\"Downloaded {downloaded / (1024 * 1024):.1f} MB so far...\")\n        else:\n            with urllib.request.urlopen(req, timeout=60) as response:\n                with open(local_apk_path, 'wb') as f:\n                    downloaded = 0\n                    while True:\n                        chunk = response.read(8192)\n                        if not chunk:\n                            break\n                        f.write(chunk)\n                        downloaded += len(chunk)\n                        # Log progress every 1MB\n                        if downloaded % (1024 * 1024) == 0:\n                            log_progress(f\"Downloaded {downloaded / (1024 * 1024):.1f} MB so far...\")\n        \n        # Verify the file was downloaded\n        file_size = os.path.getsize(local_apk_path)\n        log_progress(f\"Download completed successfully! Size: {file_size / (1024 * 1024):.2f} MB\")\n        \n        return local_apk_path\n    \n    except Exception as e:\n        log_progress(f\"Error downloading APK: {e}\", \"error\")\n        raise\n\ndef install_apk_on_device(device_id, apk_path):\n    \"\"\"\n    Install or update Termux APK on a single device using ADB\n    \"\"\"\n    try:\n        log_progress(\"Starting Termux installation/update...\", \"info\", device_id)\n        \n        # Install the APK (adb install -r for update/replace)\n        log_progress(\"Installing APK via ADB...\", \"info\", device_id)\n        adb_command = f'\"{ADB}\" -s {device_id} install -r \"{apk_path}\"'\n        log_progress(f\"ADB Command: {adb_command}\", \"info\", device_id)\n        \n        result = subprocess.run(\n            adb_command,\n            shell=True,\n            capture_output=True,\n            text=True\n        )\n        \n        if result.returncode == 0 or \"Success\" in result.stdout:\n            log_progress(\"Termux installed/updated successfully!\", \"success\", device_id)\n            return f\"[{device_id}] Success\"\n        else:\n            error_msg = result.stderr or result.stdout\n            log_progress(f\"Installation failed: {error_msg}\", \"error\", device_id)\n            return f\"[{device_id}] Failed: {error_msg}\"\n    \n    except Exception as e:\n        log_progress(f\"Error during installation: {e}\", \"error\", device_id)\n        return f\"[{device_id}] Error: {e}\"\n\ndef main():\n    \"\"\"\n    Main execution function\n    \"\"\"\n    log_progress(\"=\" * 60)\n    log_progress(\"    Termux - Install/Update Script\")\n    log_progress(\"=\" * 60)\n    \n    if not devices:\n        log_progress(\"No devices found in environment variable 'devices'\", \"error\")\n        log_progress(\"Please select devices in Cellhasher before running this script\", \"warning\")\n        return\n    \n    log_progress(f\"Target devices: {len(devices)}\")\n    for idx, device in enumerate(devices, 1):\n        log_progress(f\"    {idx}. {device}\")\n    \n    try:\n        log_progress(\"Step 1: Getting latest APK download URL...\")\n        # Step 1: Get latest APK download URL\n        apk_url, apk_name = get_latest_termux_apk()\n        \n        log_progress(\"Step 2: Downloading APK...\")\n        # Step 2: Download the APK\n        apk_path = download_apk(apk_url, apk_name)\n        \n        log_progress(f\"Step 3: Installing Termux on {len(devices)} device(s) in parallel...\")\n        # Step 3: Install on all devices in parallel\n        \n        max_workers = max(1, len(devices))\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            future_to_device = {\n                executor.submit(install_apk_on_device, device_id, apk_path): device_id \n                for device_id in devices\n            }\n            \n            for future in as_completed(future_to_device):\n                device_id = future_to_device[future]\n                try:\n                    result = future.result()\n                    log_progress(f\"Device {device_id} result: {result}\")\n                except Exception as exc:\n                    log_progress(f\"Exception for device {device_id}: {exc}\", \"error\", device_id)\n        \n        log_progress(\"Step 4: Cleaning up temporary files...\")\n        # Step 4: Cleanup - remove downloaded APK\n        if os.path.exists(apk_path):\n            os.unlink(apk_path)\n            log_progress(f\"Removed temporary APK: {apk_path}\")\n        \n        log_progress(\"=\" * 60)\n        log_progress(\"Termux installation/update completed on all devices!\", \"success\")\n        log_progress(\"=\" * 60)\n    \n    except Exception as e:\n        log_progress(f\"Script failed: {e}\", \"error\")\n        return\n\nif __name__ == \"__main__\":\n    main()"
}