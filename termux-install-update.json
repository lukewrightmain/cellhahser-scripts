{
  "id": "termux-install-update-script",
  "name": "Termux - Install/Update",
  "description": "Automatically downloads and installs/updates the latest Termux app from GitHub releases. Targets arm64-v8a APK for modern Android devices. Works on all devices in parallel using Python and ADB.",
  "category": "Custom",
  "type": "Python",
  "version": "1.0.0",
  "author": "Cellhasher Team",
  "tags": [
    "python",
    "exported",
    "termux",
    "terminal",
    "linux"
  ],
  "effects": {
    "power": {
      "reboot": false,
      "shutdown": false
    },
    "security": {
      "modifiesLockScreen": false
    }
  },
  "preRunNotice": "This script uses Tauri's HTTP client to fetch APK URLs and robust SSL handling for downloads. Make sure your Python has internet access.",
  "pythonScript": "import os\nimport time\nimport subprocess\nimport tempfile\nimport urllib.request\nimport ssl\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# Fix Windows console encoding issues\ntry:\n    import sys\n    if sys.platform == 'win32':\n        import codecs\n        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'replace')\n        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'replace')\n        print('[INIT] Fixed Windows console encoding')\nexcept Exception as e:\n    print(f'[INIT] Could not fix console encoding: {e}')\n\nprint('[INIT] Termux Install/Update Script started')\n\n# Try to import requests for better SSL handling\ntry:\n    import requests\n    HAS_REQUESTS = True\n    print(\"[INIT] ✓ Requests library available for enhanced SSL handling\")\nexcept ImportError:\n    HAS_REQUESTS = False\n    print(\"[INIT] ⚠ Requests library not available, using urllib fallback\")\n\nprint('[INIT] Getting environment variables from Cellhasher...')\n# Get environment variables from Cellhasher\nADB = os.environ.get(\"adb_path\", \"adb\")\ndevices = os.environ.get(\"devices\", \"\").split()\nAPK_URL = os.environ.get(\"apk_url\", \"\")\nAPK_NAME = os.environ.get(\"apk_name\", \"\")\n\nprint(f'[CONFIG] ADB path: {ADB}')\nprint(f'[CONFIG] Target devices: {len(devices)} device(s)')\nfor i, device in enumerate(devices, 1):\n    print(f'  [{i}] {device}')\nprint(f'[CONFIG] APK URL: {APK_URL}')\nprint(f'[CONFIG] APK Name: {APK_NAME}')\nprint(f'[CONFIG] Has requests library: {HAS_REQUESTS}')\n\n# Enhanced SSL context handling for APK download\ndef setup_ssl_context():\n    \"\"\"Set up SSL context to handle certificate issues\"\"\"\n    print('[SSL] Setting up SSL context for secure downloads...')\n\n    # Check if we have the unverified context function\n    if hasattr(ssl, '_create_unverified_context'):\n        try:\n            ssl._create_default_https_context = ssl._create_unverified_context\n            ssl._create_stdlib_context = ssl._create_unverified_context\n            print(\"[SSL] ✓ Successfully set unverified SSL context\")\n            return\n        except Exception as e:\n            print(f\"[SSL] ⚠ Failed to set unverified context: {e}\")\n    else:\n        print(\"[SSL] ⚠ _create_unverified_context not available\")\n\n    try:\n        context = ssl.create_default_context()\n        context.check_hostname = False\n        context.verify_mode = ssl.CERT_NONE\n        ssl._create_default_https_context = lambda: context\n        print(\"[SSL] ✓ Successfully set custom SSL context\")\n        return\n    except Exception as e:\n        print(f\"[SSL] ⚠ Failed to set custom context: {e}\")\n\n    try:\n        import urllib3\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n        print(\"[SSL] ✓ Disabled urllib3 warnings\")\n    except ImportError:\n        print(\"[SSL] ⚠ urllib3 not available\")\n    except Exception as e:\n        print(f\"[SSL] ⚠ Failed to disable urllib3 warnings: {e}\")\n\n    print(\"[SSL] ⚠ All SSL setup attempts failed, proceeding anyway\")\n\nprint('[SSL] Initializing SSL context setup...')\ntry:\n    setup_ssl_context()\n    print('[SSL] ✓ SSL context setup completed successfully')\nexcept Exception as e:\n    print(f'[SSL] ✗ SSL setup failed: {e}')\n    import traceback\n    traceback.print_exc()\n    print('[SSL] Continuing without SSL setup...')\n\n\ndef download_apk(apk_url, apk_name):\n    \"\"\"Download the APK using requests (preferred) or urllib as fallback\"\"\"\n    print(f'\\n[DOWNLOAD] Starting APK download process...')\n    print(f'[DOWNLOAD] Target APK: {apk_name}')\n    print(f'[DOWNLOAD] Source URL: {apk_url}')\n    \n    try:\n        # Create temporary file for the APK\n        temp_dir = tempfile.gettempdir()\n        local_apk_path = os.path.join(temp_dir, apk_name)\n        \n        print(f'[DOWNLOAD] Temporary file location: {local_apk_path}')\n\n        # Try requests first if available (better SSL handling)\n        if HAS_REQUESTS:\n            print(\"[DOWNLOAD] Using requests library for download (recommended)...\")\n            try:\n                print(\"[DOWNLOAD] Establishing connection to GitHub...\")\n                response = requests.get(\n                    apk_url,\n                    headers={'User-Agent': 'Cellhasher-Termux-Updater/1.0'},\n                    timeout=120,\n                    verify=False,\n                    stream=True\n                )\n                response.raise_for_status()\n                \n                print(f\"[DOWNLOAD] ✓ Connection established - HTTP {response.status_code}\")\n                \n                # Get total file size for progress calculation\n                total_size = int(response.headers.get('content-length', 0))\n                if total_size > 0:\n                    print(f\"[DOWNLOAD] File size: {total_size / (1024 * 1024):.1f} MB\")\n                \n                downloaded = 0\n                last_reported = 0\n                \n                print(\"[DOWNLOAD] Starting download...\")\n                with open(local_apk_path, 'wb') as f:\n                    for chunk in response.iter_content(chunk_size=8192):\n                        if chunk:\n                            f.write(chunk)\n                            downloaded += len(chunk)\n                            \n                            # Report progress every 2MB or 10% of total\n                            if total_size > 0:\n                                progress_percent = (downloaded / total_size) * 100\n                                if progress_percent - last_reported >= 10:\n                                    print(f\"[DOWNLOAD] Progress: {progress_percent:.1f}% ({downloaded / (1024 * 1024):.1f} MB)\")\n                                    last_reported = progress_percent\n                            elif downloaded - last_reported >= 2 * 1024 * 1024:\n                                print(f\"[DOWNLOAD] Downloaded: {downloaded / (1024 * 1024):.1f} MB\")\n                                last_reported = downloaded\n                \n                print(f\"[DOWNLOAD] ✓ Download completed successfully!\")\n                print(f\"[DOWNLOAD] Final size: {downloaded / (1024 * 1024):.2f} MB\")\n\n            except Exception as requests_error:\n                print(f\"[DOWNLOAD] ✗ Requests download failed: {requests_error}\")\n                print(\"[DOWNLOAD] Falling back to urllib method...\")\n                raise\n\n        # Fallback to urllib if requests failed or not available\n        print(\"[DOWNLOAD] Using urllib fallback method...\")\n        req = urllib.request.Request(apk_url)\n        req.add_header('User-Agent', 'Cellhasher-Termux-Updater/1.0')\n        \n        print(\"[DOWNLOAD] Establishing connection with urllib...\")\n        with urllib.request.urlopen(req, timeout=120) as response:\n            print(f\"[DOWNLOAD] ✓ Connection established - HTTP {response.status}\")\n            \n            total_size = int(response.headers.get('Content-Length', 0))\n            if total_size > 0:\n                print(f\"[DOWNLOAD] File size: {total_size / (1024 * 1024):.1f} MB\")\n            \n            downloaded = 0\n            last_reported = 0\n            \n            print(\"[DOWNLOAD] Starting download...\")\n            with open(local_apk_path, 'wb') as f:\n                while True:\n                    chunk = response.read(8192)\n                    if not chunk:\n                        break\n                    f.write(chunk)\n                    downloaded += len(chunk)\n                    \n                    # Report progress every 2MB\n                    if downloaded - last_reported >= 2 * 1024 * 1024:\n                        print(f\"[DOWNLOAD] Downloaded: {downloaded / (1024 * 1024):.1f} MB\")\n                        last_reported = downloaded\n            \n            print(f\"[DOWNLOAD] ✓ Download completed successfully!\")\n            print(f\"[DOWNLOAD] Final size: {downloaded / (1024 * 1024):.2f} MB\")\n\n        # Verify the file was downloaded\n        print(\"[DOWNLOAD] Verifying downloaded file...\")\n        if os.path.exists(local_apk_path):\n            file_size = os.path.getsize(local_apk_path)\n            print(f\"[DOWNLOAD] ✓ File verified on disk: {file_size} bytes ({file_size / (1024 * 1024):.2f} MB)\")\n        else:\n            raise Exception(\"Downloaded file not found on disk\")\n\n        return local_apk_path\n\n    except Exception as e:\n        print(f\"[DOWNLOAD] ✗ Download failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        raise\n\n\ndef install_apk_on_device(device_id, apk_path):\n    \"\"\"Install or update Termux APK on a single device using ADB\"\"\"\n    print(f'\\n[INSTALL] [{device_id}] Starting Termux installation/update...')\n    \n    try:\n        # Check if APK file exists\n        if not os.path.exists(apk_path):\n            error_msg = f\"APK file not found: {apk_path}\"\n            print(f\"[INSTALL] [{device_id}] ✗ {error_msg}\")\n            return f\"[{device_id}] Failed: {error_msg}\"\n\n        # Install the APK (adb install -r for update/replace)\n        print(f\"[INSTALL] [{device_id}] Preparing ADB install command...\")\n        cmd = f'\"{ADB}\" -s {device_id} install -r \"{apk_path}\"'\n        print(f\"[INSTALL] [{device_id}] Command: {cmd}\")\n        \n        print(f\"[INSTALL] [{device_id}] Executing ADB install...\")\n        result = subprocess.run(\n            cmd,\n            shell=True,\n            capture_output=True,\n            text=True,\n            timeout=120\n        )\n\n        print(f\"[INSTALL] [{device_id}] ADB exit code: {result.returncode}\")\n        \n        if result.stdout:\n            print(f\"[INSTALL] [{device_id}] ADB stdout: {result.stdout.strip()}\")\n        if result.stderr:\n            print(f\"[INSTALL] [{device_id}] ADB stderr: {result.stderr.strip()}\")\n\n        if result.returncode == 0 or \"Success\" in result.stdout:\n            print(f\"[INSTALL] [{device_id}] ✓ Termux installed/updated successfully!\")\n            return f\"[{device_id}] Success\"\n        else:\n            error_msg = result.stderr or result.stdout or \"Unknown error\"\n            print(f\"[INSTALL] [{device_id}] ✗ Installation failed: {error_msg}\")\n            return f\"[{device_id}] Failed: {error_msg}\"\n\n    except subprocess.TimeoutExpired:\n        error_msg = \"Installation timed out after 120 seconds\"\n        print(f\"[INSTALL] [{device_id}] ✗ {error_msg}\")\n        return f\"[{device_id}] Failed: {error_msg}\"\n    except Exception as e:\n        error_msg = str(e)\n        print(f\"[INSTALL] [{device_id}] ✗ Installation error: {error_msg}\")\n        import traceback\n        traceback.print_exc()\n        return f\"[{device_id}] Error: {error_msg}\"\n\n\ndef main():\n    \"\"\"Main execution function\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"                Termux - Install/Update Script\")\n    print(\"                Uses Tauri HTTP + Python Downloads\")\n    print(\"=\" * 80)\n\n    if not devices:\n        print(\"[ERROR] ✗ No devices found in environment variable 'devices'\")\n        print(\"[ERROR] Please select devices in Cellhasher before running this script\")\n        return\n\n    if not APK_URL or not APK_NAME:\n        print(\"[ERROR] ✗ No APK URL or name provided in environment variables\")\n        print(\"[ERROR] This script requires Cellhasher to fetch the download URL first\")\n        print(\"[ERROR] Make sure you're running this through Cellhasher, not directly\")\n        return\n\n    print(f'\\n[CONFIG] Target devices ({len(devices)}):')\n    for idx, device in enumerate(devices, 1):\n        print(f'  [{idx}] {device}')\n    print(f'[CONFIG] ADB executable: {ADB}')\n    print(f'[CONFIG] APK to install: {APK_NAME}')\n    print(f'[CONFIG] Download URL: {APK_URL[:80]}...' if len(APK_URL) > 80 else f'[CONFIG] Download URL: {APK_URL}')\n    print()\n\n    try:\n        # Step 1: Download the APK\n        print(\"=\" * 80)\n        print(\"Step 1: Downloading Termux APK from GitHub\")\n        print(\"=\" * 80)\n        apk_path = download_apk(APK_URL, APK_NAME)\n\n        # Step 2: Install on all devices in parallel\n        print(\"\\n\" + \"=\" * 80)\n        print(f\"Step 2: Installing Termux on {len(devices)} device(s) in parallel\")\n        print(\"=\" * 80)\n        print()\n\n        max_workers = min(max(1, len(devices)), 10)  # Limit concurrent installations\n        print(f'[INSTALL] Using {max_workers} concurrent installation threads')\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            future_to_device = {\n                executor.submit(install_apk_on_device, device_id, apk_path): device_id \n                for device_id in devices\n            }\n\n            completed_count = 0\n            for future in as_completed(future_to_device):\n                device_id = future_to_device[future]\n                try:\n                    result = future.result()\n                    completed_count += 1\n                    print(f'[PROGRESS] Completed {completed_count}/{len(devices)} devices')\n                    print(result)\n                except Exception as exc:\n                    completed_count += 1\n                    print(f'[PROGRESS] Completed {completed_count}/{len(devices)} devices')\n                    print(f\"[{device_id}] Generated an exception: {exc}\")\n\n        # Step 3: Cleanup\n        print(\"\\n[CLEANUP] Cleaning up temporary files...\")\n        if os.path.exists(apk_path):\n            try:\n                os.unlink(apk_path)\n                print(f\"[CLEANUP] ✓ Removed temporary APK: {apk_path}\")\n            except Exception as e:\n                print(f\"[CLEANUP] ⚠ Could not remove temp file: {e}\")\n\n        print(\"\\n\" + \"=\" * 80)\n        print(\"[SUCCESS] ✓ Termux installation/update completed on all devices!\")\n        print(\"=\" * 80)\n\n    except Exception as e:\n        print(f\"\\n[ERROR] ✗ Script failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return\n\nif __name__ == \"__main__\":\n    main()"
}
