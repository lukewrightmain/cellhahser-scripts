{
  "id": "78cef120-c288-4623-ae93-3c58e98fbc58",
  "name": "Acurast Lite - Install/Update (Final)",
  "description": "Automatically downloads and installs/updates the latest Acurast Lite processor app from GitHub releases. Works on all devices in parallel using Python and ADB. Uses Tauri for API calls and robust SSL handling.",
  "category": "Custom",
  "type": "Python",
  "version": "2.0.0",
  "author": "Cellhasher User",
  "tags": [
    "python",
    "exported",
    "acurast",
    "lite",
    "final"
  ],
  "effects": {
    "power": {
      "reboot": false,
      "shutdown": false
    },
    "security": {
      "modifiesLockScreen": false
    }
  },
  "preRunNotice": "This script uses Tauri's HTTP client to fetch APK URLs and robust SSL handling for downloads. Make sure your Python has internet access.",
  "pythonScript": "import os\nimport time\nimport subprocess\nimport tempfile\nimport urllib.request\nimport ssl\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# Fix Windows console encoding issues\ntry:\n    import sys\n    if sys.platform == 'win32':\n        import codecs\n        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'replace')\n        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'replace')\n        print('[DEBUG] Fixed Windows console encoding')\nexcept Exception as e:\n    print(f'[DEBUG] Could not fix console encoding: {e}')\n\nprint('[DEBUG] Script started')\n\n# Try to import requests for better SSL handling\ntry:\n    import requests\n    HAS_REQUESTS = True\n    print(\"[*] Requests library available for enhanced SSL handling\")\nexcept ImportError:\n    HAS_REQUESTS = False\n    print(\"[!] Requests library not available, using urllib fallback\")\n\nprint('[DEBUG] Getting environment variables')\n# Get environment variables from Cellhasher\nADB = os.environ.get(\"adb_path\", \"adb\")\ndevices = os.environ.get(\"devices\", \"\").split()\nAPK_URL = os.environ.get(\"apk_url\", \"\")\nAPK_NAME = os.environ.get(\"apk_name\", \"\")\n\nprint(f'[DEBUG] ADB: {ADB}')\nprint(f'[DEBUG] devices: {devices}')\nprint(f'[DEBUG] APK_URL: {APK_URL}')\nprint(f'[DEBUG] APK_NAME: {APK_NAME}')\nprint(f'[DEBUG] HAS_REQUESTS: {HAS_REQUESTS}')\n\n# Enhanced SSL context handling for APK download\ndef setup_ssl_context():\n    \"\"\"Set up SSL context to handle certificate issues\"\"\"\n    print('[DEBUG] Setting up SSL context...')\n\n    # Check if we have the unverified context function\n    if hasattr(ssl, '_create_unverified_context'):\n        try:\n            # First try: Create unverified context\n            ssl._create_default_https_context = ssl._create_unverified_context\n            ssl._create_stdlib_context = ssl._create_unverified_context\n            print(\"[SSL] ✓ Set unverified SSL context\")\n            return  # Success, exit early\n        except Exception as e:\n            print(f\"[SSL] ⚠ Failed to set unverified context: {e}\")\n    else:\n        print(\"[SSL] ! _create_unverified_context not available\")\n\n    try:\n        # Second try: Create custom context with system certificates\n        context = ssl.create_default_context()\n        context.check_hostname = False\n        context.verify_mode = ssl.CERT_NONE\n        ssl._create_default_https_context = lambda: context\n        print(\"[SSL] ✓ Set custom SSL context\")\n        return  # Success, exit early\n    except Exception as e:\n        print(f\"[SSL] ⚠ Failed to set custom context: {e}\")\n\n    try:\n        # Third try: Disable urllib3 warnings if available\n        import urllib3\n        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n        print(\"[SSL] ✓ Disabled urllib3 warnings\")\n    except ImportError:\n        print(\"[SSL] ! urllib3 not available\")\n    except Exception as e:\n        print(f\"[SSL] ⚠ Failed to disable urllib3 warnings: {e}\")\n\n    print(\"[SSL] ! All SSL setup attempts failed, proceeding anyway\")\n\nprint('[DEBUG] Calling setup_ssl_context()')\n# Set up SSL context\ntry:\n    setup_ssl_context()\n    print('[DEBUG] SSL setup completed')\nexcept Exception as e:\n    print(f'[DEBUG] SSL setup failed with exception: {e}')\n    import traceback\n    traceback.print_exc()\n    print('[DEBUG] Continuing without SSL setup...')\n\ndef download_apk(apk_url, apk_name):\n    \"\"\"Download the APK using requests (preferred) or urllib as fallback\"\"\"\n    try:\n        # Create temporary file for the APK\n        temp_dir = tempfile.gettempdir()\n        local_apk_path = os.path.join(temp_dir, apk_name)\n\n        print(f\"[*] Downloading {apk_name}...\")\n        print(f\"[*] Saving to: {local_apk_path}\")\n        print(f\"[*] From URL: {apk_url}\")\n\n        # Try requests first if available (better SSL handling)\n        if HAS_REQUESTS:\n            print(\"[*] Using requests library for download...\")\n            try:\n                response = requests.get(\n                    apk_url,\n                    headers={'User-Agent': 'Cellhasher-Acurast-Updater/1.0'},\n                    timeout=120,\n                    verify=False,  # Disable SSL verification\n                    stream=True\n                )\n                response.raise_for_status()\n\n                print(f\"[✓] Download started - Status: {response.status_code}\")\n\n                with open(local_apk_path, 'wb') as f:\n                    total_size = 0\n                    last_reported = 0\n                    for chunk in response.iter_content(chunk_size=8192):\n                        if chunk:\n                            f.write(chunk)\n                            total_size += len(chunk)\n\n                            # Report progress every 10MB\n                            if total_size - last_reported >= 10 * 1024 * 1024:\n                                print(f\"[*] Downloaded {total_size / (1024 * 1024):.1f} MB...\")\n                                last_reported = total_size\n\n                print(f\"[✓] Downloaded successfully! Size: {total_size / (1024 * 1024):.2f} MB\")\n\n            except Exception as requests_error:\n                print(f\"[!] Requests failed: {requests_error}, falling back to urllib...\")\n                raise  # Fall through to urllib\n\n        # Fallback to urllib if requests failed or not available\n        print(\"[*] Using urllib for download...\")\n        req = urllib.request.Request(apk_url)\n        req.add_header('User-Agent', 'Cellhasher-Acurast-Updater/1.0')\n\n        with urllib.request.urlopen(req, timeout=120) as response:\n            print(f\"[✓] Download started - Status: {response.status}\")\n\n            with open(local_apk_path, 'wb') as f:\n                total_size = 0\n                last_reported = 0\n                while True:\n                    chunk = response.read(8192)\n                    if not chunk:\n                        break\n                    f.write(chunk)\n                    total_size += len(chunk)\n\n                    # Report progress every 10MB\n                    if total_size - last_reported >= 10 * 1024 * 1024:\n                        print(f\"[*] Downloaded {total_size / (1024 * 1024):.1f} MB...\")\n                        last_reported = total_size\n\n            print(f\"[✓] Downloaded successfully! Size: {total_size / (1024 * 1024):.2f} MB\")\n\n        # Verify the file was downloaded\n        if os.path.exists(local_apk_path):\n            file_size = os.path.getsize(local_apk_path)\n            print(f\"[✓] File verified on disk: {file_size} bytes\")\n        else:\n            raise Exception(\"Downloaded file not found on disk\")\n\n        return local_apk_path\n\n    except Exception as e:\n        print(f\"[✗] Error downloading APK: {e}\")\n        import traceback\n        traceback.print_exc()\n        raise\n\ndef install_apk_on_device(device_id, apk_path):\n    \"\"\"Install or update Acurast Lite APK on a single device using ADB\"\"\"\n    try:\n        print(f\"[{device_id}] Starting Acurast Lite installation/update...\")\n\n        # Check if APK file exists\n        if not os.path.exists(apk_path):\n            return f\"[{device_id}] Failed: APK file not found\"\n\n        # Install the APK (adb install -r for update/replace)\n        print(f\"[{device_id}] Installing APK...\")\n        cmd = f'\"{ADB}\" -s {device_id} install -r \"{apk_path}\"'\n        print(f\"[{device_id}] Running: {cmd}\")\n\n        result = subprocess.run(\n            cmd,\n            shell=True,\n            capture_output=True,\n            text=True,\n            timeout=120\n        )\n\n        print(f\"[{device_id}] ADB exit code: {result.returncode}\")\n        if result.stdout:\n            print(f\"[{device_id}] ADB stdout: {result.stdout.strip()}\")\n        if result.stderr:\n            print(f\"[{device_id}] ADB stderr: {result.stderr.strip()}\")\n\n        if result.returncode == 0 or \"Success\" in result.stdout:\n            print(f\"[{device_id}] ✓ Acurast Lite installed/updated successfully!\")\n            return f\"[{device_id}] Success\"\n        else:\n            error_msg = result.stderr or result.stdout or \"Unknown error\"\n            print(f\"[{device_id}] ✗ Installation failed: {error_msg}\")\n            return f\"[{device_id}] Failed: {error_msg}\"\n\n    except subprocess.TimeoutExpired:\n        print(f\"[{device_id}] ✗ Installation timed out\")\n        return f\"[{device_id}] Failed: Timeout\"\n    except Exception as e:\n        print(f\"[{device_id}] ✗ Error: {e}\")\n        import traceback\n        traceback.print_exc()\n        return f\"[{device_id}] Error: {e}\"\n\ndef main():\n    \"\"\"Main execution function\"\"\"\n    print(\"=\" * 60)\n    print(\"    Acurast Lite - Install/Update Script (Final)\")\n    print(\"    Uses Tauri HTTP + Python Downloads\")\n    print(\"=\" * 60)\n\n    if not devices:\n        print(\"[✗] No devices found in environment variable 'devices'\")\n        print(\"[!] Please select devices in Cellhasher before running this script\")\n        return\n\n    if not APK_URL or not APK_NAME:\n        print(\"[✗] No APK URL or name provided in environment variables\")\n        print(\"[!] This script requires Cellhasher to fetch the download URL first\")\n        print(\"[!] Make sure you're running this through Cellhasher, not directly\")\n        return\n\n    print(f\"[*] Target devices: {len(devices)}\")\n    for idx, device in enumerate(devices, 1):\n        print(f\"    {idx}. {device}\")\n    print(f\"[*] ADB path: {ADB}\")\n    print(f\"[*] APK to install: {APK_NAME}\")\n    print(f\"[*] Download URL: {APK_URL}\")\n    print()\n\n    try:\n        # Step 1: Download the APK (URL provided by Cellhasher/Tauri)\n        print(\"=\" * 60)\n        print(\"Step 1: Downloading APK from GitHub\")\n        print(\"=\" * 60)\n        apk_path = download_apk(APK_URL, APK_NAME)\n\n        # Step 2: Install on all devices in parallel\n        print(\"\\n\" + \"=\" * 60)\n        print(f\"Step 2: Installing Acurast Lite on {len(devices)} device(s) in parallel...\")\n        print(\"=\" * 60)\n        print()\n\n        max_workers = min(max(1, len(devices)), 10)  # Limit concurrent installations\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            future_to_device = {\n                executor.submit(install_apk_on_device, device_id, apk_path): device_id\n                for device_id in devices\n            }\n\n            for future in as_completed(future_to_device):\n                device_id = future_to_device[future]\n                try:\n                    result = future.result()\n                    print(result)\n                except Exception as exc:\n                    print(f\"[{device_id}] Generated an exception: {exc}\")\n\n        # Step 3: Cleanup - remove downloaded APK\n        print(\"\\n[*] Cleaning up temporary files...\")\n        if os.path.exists(apk_path):\n            try:\n                os.unlink(apk_path)\n                print(f\"[✓] Removed temporary APK: {apk_path}\")\n            except Exception as e:\n                print(f\"[!] Could not remove temp file: {e}\")\n\n        print(\"\\n\" + \"=\" * 60)\n        print(\"[✓] Acurast Lite installation/update completed on all devices!\")\n        print(\"=\" * 60)\n\n    except Exception as e:\n        print(f\"\\n[✗] Script failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return\n\nif __name__ == \"__main__\":\n    main()"
}
