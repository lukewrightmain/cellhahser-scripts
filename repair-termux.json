{
  "id": "script-1759694753857",
  "name": "Repair Termux (pkg cache)",
  "description": "Runs commands in Termux on affected devices to resolve mirror/package issues",
  "category": "Custom",
  "type": "Python",
  "version": "1.0.0",
  "author": "Cellhasher Team",
  "tags": [
    "python",
    "repair",
    "termux"
  ],
  "effects": {
    "power": {
      "reboot": false,
      "shutdown": false
    },
    "security": {
      "modifiesLockScreen": false
    }
  },
  "preRunNotice": "This Python script script is from The Cellhasher Team",
  "pythonScript": "import os, time, subprocess, tempfile\r\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\r\n\r\nADB = os.environ.get(\"adb_path\", \"adb\")\r\ndevices = os.environ.get(\"devices\", \"\").split()\r\n\r\nrepair_script_content = r'''#!/data/data/com.termux/files/usr/bin/bash\r\necho \"[+] Repairing Termux APT state...\"\r\nrm -rf $PREFIX/var/lib/apt/lists/*\r\nrm -rf $PREFIX/var/cache/apt/archives/*\r\npkg clean\r\npkg update -y\r\npkg upgrade -y\r\necho \"[+] Done. You can re-run your miner installer now.\"\r\n'''\r\n\r\ndef repair_device(device_id, script_path):\r\n    try:\r\n        print(f\"[{device_id}] Starting APT repair...\")\r\n\r\n        subprocess.run(f\"{ADB} -s {device_id} shell am force-stop com.termux\", shell=True)\r\n        time.sleep(1)\r\n\r\n        device_temp_path = \"/data/local/tmp/repair.sh\"\r\n        print(f\"[{device_id}] Pushing repair script...\")\r\n        subprocess.run(f'{ADB} -s {device_id} push \"{script_path}\" \"{device_temp_path}\"', shell=True, check=True)\r\n\r\n        print(f\"[{device_id}] Making script executable...\")\r\n        subprocess.run(f\"{ADB} -s {device_id} shell chmod 755 {device_temp_path}\", shell=True, check=True)\r\n\r\n        print(f\"[{device_id}] Launching Termux and waiting for initialization...\")\r\n        subprocess.run(f\"{ADB} -s {device_id} shell am start -n com.termux/com.termux.app.TermuxActivity\", shell=True)\r\n        time.sleep(10)  # Wait 10 seconds for Termux to fully load\r\n\r\n        # Execute the repair script\r\n        adb_typed_cmd = \"bash%s/data/local/tmp/repair.sh\"\r\n        subprocess.run(f\"{ADB} -s {device_id} shell input text \\\"{adb_typed_cmd}\\\"\", shell=True)\r\n        time.sleep(1)\r\n        subprocess.run(f\"{ADB} -s {device_id} shell input keyevent 66\", shell=True)\r\n\r\n        print(f\"[{device_id}] APT repair process started successfully!\")\r\n        return f\"[{device_id}] Success\"\r\n    except Exception as e:\r\n        print(f\"[{device_id}] Error: {e}\")\r\n        return f\"[{device_id}] Error: {e}\"\r\n\r\n# Write the script with UTF-8 + LF to avoid cp1252/CRLF issues\r\nwith tempfile.NamedTemporaryFile(mode='w', encoding='utf-8', newline='\\n', delete=False, suffix='.sh') as f:\r\n    f.write(repair_script_content)\r\n    local_script_path = f.name\r\n\r\nif not devices:\r\n    print(\"No devices in $devices\")\r\nelse:\r\n    print(f\"Saved repair script to {local_script_path}\")\r\n    print(\"=== Starting APT Repair (Parallel) ===\")\r\n\r\n    max_workers = max(1, len(devices))\r\n    with ThreadPoolExecutor(max_workers=max_workers) as executor:\r\n        future_to_device = {executor.submit(repair_device, d, local_script_path): d for d in devices}\r\n        for future in as_completed(future_to_device):\r\n            device_id = future_to_device[future]\r\n            try:\r\n                result = future.result()\r\n                print(result)\r\n            except Exception as exc:\r\n                print(f\"[{device_id}] Generated an exception: {exc}\")\r\n\r\n    os.unlink(local_script_path)\r\n    print(\"Repair commands sent to all devices. Repair process may take several minutes.\")"
}
